#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_nonuniform_qualifier : enable

struct Meshlet {
  uint vertex_offset;
  uint triangle_offset;
  uint vertex_count;
  uint triangle_count;
};

struct MeshletCull{
  vec4 selfSphere;
  vec4 parentSphere;
  float selfError;
  float parentError;
  uint lod;
  uint dummy;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 124) out;

layout(set = 0 , binding = 1) buffer Meshlets { Meshlet meshlets[]; } gMeshlets[];
layout(set = 0 , binding = 1) buffer MeshletVertices { uint meshlet_vertices[]; } gMeshletVert[];
layout(set = 0 , binding = 1) buffer MeshletTriangles { uint meshlet_triangles[]; } gMeshletTri[];
layout(set = 0 , binding = 1) buffer Vertices { vec4 vertices[]; } gVertices[];
layout(set = 0 , binding = 1) buffer MeshletCulls { MeshletCull meshlet_culls[]; } gMeshletCulls[];

layout (set = 0,binding = 0) uniform UniformBufferObject {
  vec4 cameraPos;
  mat4 mvp;
  uint meshlet_count;
  float fov;
} ubo[];

layout(set = 1, binding = 0) uniform BindlessMapping {
  uint meshletId;
  uint meshletVertId;
  uint meshletTriId;
  uint vxbufId;
  uint cullId;
  uint uniformId;
  uint dummy1;
  uint dummy2;
} bindlessMapping;

layout(location = 0) out vec3 fragColor[];

// color maps, 24 colors
vec4 colorMap[24] = vec4[24](
  vec4(1.0, 0.0, 0.0, 1.0),
  vec4(0.0, 1.0, 0.0, 1.0),
  vec4(0.0, 0.0, 1.0, 1.0),
  vec4(1.0, 1.0, 0.0, 1.0),
  vec4(1.0, 0.0, 1.0, 1.0),
  vec4(0.0, 1.0, 1.0, 1.0),
  vec4(1.0, 1.0, 1.0, 1.0),
  vec4(0.5, 0.0, 0.0, 1.0),
  vec4(0.0, 0.5, 0.0, 1.0),
  vec4(0.0, 0.0, 0.5, 1.0),
  vec4(0.5, 0.5, 0.0, 1.0),
  vec4(0.5, 0.0, 0.5, 1.0),
  vec4(0.0, 0.5, 0.5, 1.0),
  vec4(0.5, 0.5, 0.5, 1.0),
  vec4(0.25, 0.0, 0.0, 1.0),
  vec4(0.0, 0.25, 0.0, 1.0),
  vec4(0.0, 0.0, 0.25, 1.0),
  vec4(0.25, 0.25, 0.0, 1.0),
  vec4(0.25, 0.0, 0.25, 1.0),
  vec4(0.0, 0.25, 0.25, 1.0),
  vec4(0.25, 0.25, 0.25, 1.0),
  vec4(0.125, 0.0, 0.0, 1.0),
  vec4(0.0, 0.125, 0.0, 1.0),
  vec4(0.0, 0.0, 0.125, 1.0)
);


uint readTriangleIndex(uint meshletId, uint offset){
  uint offsetInUint8Local = offset;
  uint meshletTriOffset = gMeshlets[bindlessMapping.meshletId].meshlets[meshletId].triangle_offset;
  uint meshletVertOffset = gMeshlets[bindlessMapping.meshletId].meshlets[meshletId].vertex_offset;
  uint totalUint8Offset = meshletTriOffset + offsetInUint8Local;
  
  uint indexDataU32 = gMeshletTri[bindlessMapping.meshletTriId].meshlet_triangles[totalUint8Offset];
  return indexDataU32;
  //uint totalVertOffset = meshletVertOffset + indexDataU32;
  //return gMeshletVert[bindlessMapping.meshletVertId].meshlet_vertices[totalVertOffset];
}

uint readVertIndex(uint meshletId, uint offset){
  uint offsetInUint8Local = offset;
  uint meshletVertOffset = gMeshlets[bindlessMapping.meshletId].meshlets[meshletId].vertex_offset;
  uint totalUint8Offset = meshletVertOffset + offsetInUint8Local;
  return gMeshletVert[bindlessMapping.meshletVertId].meshlet_vertices[totalUint8Offset];
}

float computeProjectedRadius(float fovy,float d,float r) {
  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space
  float fov = fovy / 2;
  return 1.0 / tan(fov) * r / sqrt(d * d - r * r); 
}

void main() {
  uint mi = gl_WorkGroupID.x;
  uint lodLevel = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].lod;
  // Meshlet culling (although its lacking of efficiency. Performance and data structure will be improved in the future)
  vec4 selfSphere = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].selfSphere;
  vec4 parentSphere = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].parentSphere;
  float selfError = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].selfError;
  float parentError = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].parentError;

  float fov = ubo[bindlessMapping.uniformId].fov;
  vec3 cameraPos = ubo[bindlessMapping.uniformId].cameraPos.xyz;

  // get projected radius for parent
  const float ACCEPTANCE_THRESHOLD = 0.01;
  bool parentCull = true;
  float ppr = 10.0;
  if(parentError < 1e40){
    vec3 parentCenter = parentSphere.xyz;
    vec3 parentToCamera = cameraPos - parentCenter;
    float parentDistance = length(parentToCamera);
    float parentErrorRadius = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].parentError;
    float parentProjectedRadius = computeProjectedRadius(fov, parentDistance, parentErrorRadius);
    parentCull = parentProjectedRadius >= ACCEPTANCE_THRESHOLD;
  }
  // if parent is not culled, then return
  if(!parentCull){
    SetMeshOutputsEXT(0, 0);
    return;
  }

  bool selfCull = false;
  uint selfLod = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].lod;
  float spr = 10.0;
  if(selfLod != 0){
    vec3 selfCenter = selfSphere.xyz;
    vec3 selfToCamera = cameraPos - selfCenter;
    float selfDistance = length(selfToCamera);
    float selfErrorRadius = gMeshletCulls[bindlessMapping.cullId].meshlet_culls[mi].selfError;
    float selfProjectedRadius = computeProjectedRadius(fov, selfDistance, selfErrorRadius);
    selfCull = selfProjectedRadius >= ACCEPTANCE_THRESHOLD;
    spr = selfProjectedRadius;
  }
  // if self is culled, then return
  if(selfCull){
    SetMeshOutputsEXT(0, 0);
    return;
  }

  // Meshlet display
  uint totalTris = gMeshlets[bindlessMapping.meshletId].meshlets[mi].triangle_count;
  uint totalVerts = gMeshlets[bindlessMapping.meshletId].meshlets[mi].vertex_count;
  SetMeshOutputsEXT(totalVerts, totalTris);
  for(uint i=0;i<totalVerts;i++){
    uint vi = readVertIndex(mi, i);
    vec3 v0 = gVertices[bindlessMapping.vxbufId].vertices[vi].xyz;
    gl_MeshVerticesEXT[i].gl_Position = ubo[bindlessMapping.uniformId].mvp * vec4(v0.xyz, 1.0);
    fragColor[i] = vec3(spr,spr,spr);
    fragColor[i] = colorMap[selfLod % 24].rgb;
  }

  for(uint i = 0; i < totalTris; i++){
    uint triIndexA = readTriangleIndex(mi, i*3 + 0);
    uint triIndexB = readTriangleIndex(mi, i*3 + 1);
    uint triIndexC = readTriangleIndex(mi, i*3 + 2);
    gl_PrimitiveTriangleIndicesEXT[i] = uvec3(triIndexA, triIndexB, triIndexC);
  }

}